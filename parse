#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2022 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

use Chj::xperlfunc ":all";
use FP::List;
use FP::Lazy;

use Getopt::Long;
# use FP::Repl::Trap; #

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname file(s)

  Options:

    --print   just print each file in the new format
    --merge   merge then print

  ($email_full)
";
exit (@_ ? 1 : 0);
}

our $verbose=0;
our $opt_print;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "print"=> \$opt_print,
	   ) or exit 1;
usage unless @ARGV;


use Date::Parse ();

sub unixtime($str) {
    Date::Parse::str2time($str) // die "bogus date: '$str'"
}

sub trimboth($str) {
    $str=~ s/^\s+//s;
    $str=~ s/\s+\z//s;
    $str
}

my $uniform_name = sub($str) {
    # $str=~ s/_//sg;
    # actually seems to be using same way on both ends
    $str
};

package Item {

    sub prep($time, $name, $str) {
        my $is_continuation = 0;
        map {
            my $C = $is_continuation ? "..." : "";
            $is_continuation = 1;
            "$time\t$name\t$C\t$_\n"
        } split /\n/, main::trimboth($str)
    }

    use FP::Struct [ "unixtime", "name", "datestr", "content" ]
        => "FP::Struct::Show", "FP::Struct::Equal";

    sub myprintvals($self) {
        prep($self->unixtime, $uniform_name->($self->name), $self->content)
    }
    _END_
}
Item::constructors->import;

sub parse($path) {
    my $s = xgetfile_utf8 $path;
    my @items;
    while ($s=~ m/\G\n?(\w+) on ([^\n]*?) said:(.*?)(\s*$|\n\w+ on [^\n]*? said:)/sgc) {
        my ($name, $datestr, $content, $after) = ($1, $2, $3, $4);
        push @items, Item(unixtime($datestr), $name, $datestr,
                          trimboth($content));
        last if $after =~ /^\s*\z/s;
        pos($s) -= length $after;
    }
    list @items
}

binmode *STDOUT{IO}, ":encoding(utf-8)" or die;

my @itemss = map { parse $_ } @ARGV;

sub printstream($items) {
    $items->for_each(
        sub ($p) {
            xprint $p->myprintvals;
        });
}

sub merge($vs1, $vs2) {
    if ($vs1->is_null) {
        $vs2
    } elsif ($vs2->is_null) {
        $vs1
    } else {
        lazy {
            my ($a, $b) = ($vs1->first, $vs2->first);
            if ($a->content eq $b->content) {
                my $rest = merge($vs1->rest, $vs2->rest);
                cons $a, $rest
            } else {
                if ($a->unixtime < $b->unixtime) {
                    cons $a, merge($vs1->rest, $vs2)
                } else {
                    cons $b, merge($vs1, $vs2->rest)
                }
            }
        }
    }
}

if ($opt_print) {
    for my $items (@itemss) {
        printstream $items;
    }
} else {
    @itemss == 2 or die "can only handle 2 files to merge for now";
    my $s = merge (@itemss);
    use FP::Repl; repl;
    printstream $s;
}


#use Chj::ruse;
#use Chj::Backtrace; 

